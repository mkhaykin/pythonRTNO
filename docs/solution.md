## Решение:
### Описание:

В реализации несколько отошел от указанных задач сохранив при этом реализацию цели. Опять же пункт
"подходите творчески к решению задачи" мне кажется располагает.

#### Важные изменения:
 - в качестве клиента telegram использовал aiogram, а не telegram-api;
 - соответственно отказался от webhook;
 - самого бота вынес в отдельный контейнер;
 - для передачи сообщений от fastapi к bot использовал RabbitMQ.

### Общая схема работы:

Aiorgam мониторит telegram, при получении сообщений "дергает" бэк (fastapi). Далее уже он занимается обработкой сообщения.
Обработка сообщений производится в background, для передачи боту на отправку используется механизм очереди (RabbitMQ).

#### Ограничения:
- не проверяем старые пользовательские сообщения;
- не контролирует доступность backend;
- оператор единственный и его id - константа в коде;
- не контролирует отсутствие ответа от оператора;
- т.к. оператор может отвечать на запросы нескольких пользователей, то для ответа 
необходимо отвечать на пересланное сообщение от пользователя;
- не реализована отдельная регистрация операторов, возможность выбора на какие вопросы
оператор готов отвечать и т.п. (этого не было в ТЗ, но стоило бы реализовать);
- после 5 минут отсутствия вопросов от пользователя общение с оператором прекращается;
- если оператор пишет сообщения боту, то они ему и пересылаются для ответа,
а потом его ответ пересылается ему же. Очевидно, это не то, что ожидается.

Полагаю, данные ограничения для тестового задания приемлемы. 
Часть функционала не реализована "в натуре", но в коде оставлены комментарии 
(TODO) по возможной реализации. 

### Работа с системой.
Пользователь пишет сообщение, если это сообщение уже часть диалога с оператором, 
то сообщение пересылается непосредственно оператору. Оператор _отвечает_ на сообщение
и этот ответ отправляется пользователю.

Если же сообщение от пользователя новое, то бэк проверяет: является ли сообщение запросом на общение с оператором
(тут задействуем внешний api vsegpt.ru). Если не так, то 
отправляем пользователю автоматический ответ. В противном случае отправляем 
информационное сообщение "переключаю на человека" и переключаем диалог на оператора.

#### Ограничения: 
 - внешний api платный, при не возможности получить ответ, любое сообщение 
трактуется как простое (не требует подключения оператора). Для отладки предусмотрена
проверка на "позови человека" в тексте сообщения, после которого диалог переключается на 
оператора;
 - в текущей реализации если оператор пишет сообщения, то они ему и пересылаются для ответа,
а потом его ответ пересылается ему же. Очевидно, это не то, что ожидается, но пока так.


### Зоны ответственности:
1. Aiorgam отвечает за работу с Telegram, он же сохраняет все сообщения которые через него проходят в [Messages].
Далее он через fastapi /message передает сообщения в бэк и постоянно слушает rabbit 
на предмет появления новых сообщений для отправки / пересылки.

_Технически нам ничего не мешает использовать в качестве ID идентификатор непосредственно Telegram, но может появиться
боль, если мы потом введем еще один канал поступления обращений._

2. FastAPI - две ручки:
 - / - hello word;
 - /message - передача сообщения от бота в бэк.

Логика довольно простая, поэтому все в одном модуле. Бэк определяет тип сообщения (вопрос / ответ),
сохраняет его в соответствующие таблицы [Questions] и [Answers]. 
Далее или дает авто ответ или переводит общение на оператора. 
ID в [Questions] и [Answers] - это ID из [Messages] (он передается из бота в бэк 
вместе с самим сообщением).

Почему такая "заморочка" с ID:
 - чуть проще отладка;
 - меньше сущностей;
 - единственная точка генерации ID объектов - таблица [Messages].

3. ChatGPT.
Для запроса использовался api.vsegpt.ru. Скорее всего на нем уже пустой баланс, а т.к. отсутствие/ошибка при ответе
трактуется как отрицательный ответ, поэтому в код вшито переключение на оператора при непосредственном вызове
(команда "позови человека")


### Smell:
 - дублируем часть данных в таблице [Messages] и [Questions]/[Answers];

Отчасти это связано с тем, что система тестовая и на такое можно закрыть глаза. Опять же удобно для траблшутинга.
Полагаю стоит сохранять в [Messages] весь JSON и может даже перенести их с Postgres на что-нить NOSQL.
Мы эти сообщения так или иначе вообще править не должны, максимум какие-то флаги "обработано" и т.п.
Опять же [Messages] мы можем "подтирать" по мере устаревания, все наше "боевое" общение идет в [Questions]/[Answers].
